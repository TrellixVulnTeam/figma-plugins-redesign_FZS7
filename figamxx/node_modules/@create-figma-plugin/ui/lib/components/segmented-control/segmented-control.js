/** @jsx h */
import { h } from 'preact';
import { useCallback } from 'preact/hooks';
import { DOWN_KEY_CODE, ESCAPE_KEY_CODE, LEFT_KEY_CODE, RIGHT_KEY_CODE, UP_KEY_CODE } from '../../utilities/key-codes';
import styles from './segmented-control.scss';
export function SegmentedControl({ disabled: disabled, focused: isFocused, name, onChange, options, propagateEscapeKeyDown = true, value, ...rest }) {
    const handleChange = useCallback(function (event) {
        const index = event.target.getAttribute('data-index');
        if (index === null) {
            return;
        }
        const newValue = options[parseInt(index)].value;
        onChange({ [name]: newValue }, newValue, name, event);
    }, [name, onChange, options]);
    const handleKeyDown = useCallback(function (event) {
        const keyCode = event.keyCode;
        if (keyCode === ESCAPE_KEY_CODE) {
            if (propagateEscapeKeyDown === false) {
                event.stopPropagation();
            }
            ;
            event.target.blur();
            return;
        }
        if (keyCode === DOWN_KEY_CODE ||
            keyCode === LEFT_KEY_CODE ||
            keyCode === RIGHT_KEY_CODE ||
            keyCode === UP_KEY_CODE) {
            if (value === null) {
                const newValue = options[0].value;
                onChange({ [name]: newValue }, newValue, name, event);
                return;
            }
            const currentIndex = options.findIndex(function (option) {
                return option.value === value;
            });
            const nextIndex = resolveNextIndex(options, currentIndex, keyCode === LEFT_KEY_CODE || keyCode === UP_KEY_CODE ? -1 : 1);
            if (nextIndex !== -1) {
                const newValue = options[nextIndex].value;
                onChange({ [name]: newValue }, newValue, name, event);
            }
        }
    }, [name, onChange, options, propagateEscapeKeyDown, value]);
    return (h("div", { class: styles.segmentedControl, "data-initial-focus": isFocused === true, onKeyDown: disabled === true ? undefined : handleKeyDown, tabIndex: disabled === true ? undefined : 0 }, options.map(function (option, index) {
        const text = typeof option.text === 'undefined' ? option.value : option.text;
        return (h("label", { key: index, class: styles.label },
            h("input", Object.assign({}, rest, { checked: value === option.value, class: styles.input, "data-index": index, disabled: disabled === true || option.disabled === true, name: name, onChange: handleChange, tabIndex: -1, type: "radio", value: option.value === null ? undefined : `${option.value}` })),
            h("div", { class: styles.text }, text)));
    })));
}
function resolveNextIndex(options, currentIndex, delta) {
    let nextIndex = currentIndex;
    do {
        nextIndex += delta;
        if (nextIndex === -1) {
            nextIndex = options.length - 1;
        }
        if (nextIndex === options.length) {
            nextIndex = 0;
        }
        if (options[nextIndex].disabled !== true) {
            return nextIndex;
        }
    } while (nextIndex !== currentIndex);
    return -1;
}
//# sourceMappingURL=segmented-control.js.map